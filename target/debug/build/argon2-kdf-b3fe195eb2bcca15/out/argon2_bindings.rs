/* automatically generated by rust-bindgen 0.69.4 */

pub const __WORDSIZE: u32 = 64;
pub const __has_safe_buffers: u32 = 1;
pub const __DARWIN_ONLY_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const __DARWIN_ONLY_VERS_1050: u32 = 1;
pub const __DARWIN_UNIX03: u32 = 1;
pub const __DARWIN_64_BIT_INO_T: u32 = 1;
pub const __DARWIN_VERS_1050: u32 = 1;
pub const __DARWIN_NON_CANCELABLE: u32 = 0;
pub const __DARWIN_SUF_EXTSN: &[u8; 14] = b"$DARWIN_EXTSN\0";
pub const __DARWIN_C_ANSI: u32 = 4096;
pub const __DARWIN_C_FULL: u32 = 900000;
pub const __DARWIN_C_LEVEL: u32 = 900000;
pub const __STDC_WANT_LIB_EXT1__: u32 = 1;
pub const __DARWIN_NO_LONG_LONG: u32 = 0;
pub const _DARWIN_FEATURE_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_64_BIT_INODE: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_VERS_1050: u32 = 1;
pub const _DARWIN_FEATURE_ONLY_UNIX_CONFORMANCE: u32 = 1;
pub const _DARWIN_FEATURE_UNIX_CONFORMANCE: u32 = 3;
pub const __has_ptrcheck: u32 = 0;
pub const __PTHREAD_SIZE__: u32 = 8176;
pub const __PTHREAD_ATTR_SIZE__: u32 = 56;
pub const __PTHREAD_MUTEXATTR_SIZE__: u32 = 8;
pub const __PTHREAD_MUTEX_SIZE__: u32 = 56;
pub const __PTHREAD_CONDATTR_SIZE__: u32 = 8;
pub const __PTHREAD_COND_SIZE__: u32 = 40;
pub const __PTHREAD_ONCE_SIZE__: u32 = 8;
pub const __PTHREAD_RWLOCK_SIZE__: u32 = 192;
pub const __PTHREAD_RWLOCKATTR_SIZE__: u32 = 16;
pub const INT8_MAX: u32 = 127;
pub const INT16_MAX: u32 = 32767;
pub const INT32_MAX: u32 = 2147483647;
pub const INT64_MAX: u64 = 9223372036854775807;
pub const INT8_MIN: i32 = -128;
pub const INT16_MIN: i32 = -32768;
pub const INT32_MIN: i32 = -2147483648;
pub const INT64_MIN: i64 = -9223372036854775808;
pub const UINT8_MAX: u32 = 255;
pub const UINT16_MAX: u32 = 65535;
pub const UINT32_MAX: u32 = 4294967295;
pub const UINT64_MAX: i32 = -1;
pub const INT_LEAST8_MIN: i32 = -128;
pub const INT_LEAST16_MIN: i32 = -32768;
pub const INT_LEAST32_MIN: i32 = -2147483648;
pub const INT_LEAST64_MIN: i64 = -9223372036854775808;
pub const INT_LEAST8_MAX: u32 = 127;
pub const INT_LEAST16_MAX: u32 = 32767;
pub const INT_LEAST32_MAX: u32 = 2147483647;
pub const INT_LEAST64_MAX: u64 = 9223372036854775807;
pub const UINT_LEAST8_MAX: u32 = 255;
pub const UINT_LEAST16_MAX: u32 = 65535;
pub const UINT_LEAST32_MAX: u32 = 4294967295;
pub const UINT_LEAST64_MAX: i32 = -1;
pub const INT_FAST8_MIN: i32 = -128;
pub const INT_FAST16_MIN: i32 = -32768;
pub const INT_FAST32_MIN: i32 = -2147483648;
pub const INT_FAST64_MIN: i64 = -9223372036854775808;
pub const INT_FAST8_MAX: u32 = 127;
pub const INT_FAST16_MAX: u32 = 32767;
pub const INT_FAST32_MAX: u32 = 2147483647;
pub const INT_FAST64_MAX: u64 = 9223372036854775807;
pub const UINT_FAST8_MAX: u32 = 255;
pub const UINT_FAST16_MAX: u32 = 65535;
pub const UINT_FAST32_MAX: u32 = 4294967295;
pub const UINT_FAST64_MAX: i32 = -1;
pub const INTPTR_MAX: u64 = 9223372036854775807;
pub const INTPTR_MIN: i64 = -9223372036854775808;
pub const UINTPTR_MAX: i32 = -1;
pub const SIZE_MAX: i32 = -1;
pub const RSIZE_MAX: i32 = -1;
pub const WINT_MIN: i32 = -2147483648;
pub const WINT_MAX: u32 = 2147483647;
pub const SIG_ATOMIC_MIN: i32 = -2147483648;
pub const SIG_ATOMIC_MAX: u32 = 2147483647;
pub const __DARWIN_CLK_TCK: u32 = 100;
pub const MB_LEN_MAX: u32 = 6;
pub const CLK_TCK: u32 = 100;
pub const CHAR_BIT: u32 = 8;
pub const SCHAR_MAX: u32 = 127;
pub const SCHAR_MIN: i32 = -128;
pub const UCHAR_MAX: u32 = 255;
pub const CHAR_MAX: u32 = 127;
pub const CHAR_MIN: i32 = -128;
pub const USHRT_MAX: u32 = 65535;
pub const SHRT_MAX: u32 = 32767;
pub const SHRT_MIN: i32 = -32768;
pub const UINT_MAX: u32 = 4294967295;
pub const INT_MAX: u32 = 2147483647;
pub const INT_MIN: i32 = -2147483648;
pub const ULONG_MAX: i32 = -1;
pub const LONG_MAX: u64 = 9223372036854775807;
pub const LONG_MIN: i64 = -9223372036854775808;
pub const ULLONG_MAX: i32 = -1;
pub const LLONG_MAX: u64 = 9223372036854775807;
pub const LLONG_MIN: i64 = -9223372036854775808;
pub const LONG_BIT: u32 = 64;
pub const SSIZE_MAX: u64 = 9223372036854775807;
pub const WORD_BIT: u32 = 32;
pub const SIZE_T_MAX: i32 = -1;
pub const UQUAD_MAX: i32 = -1;
pub const QUAD_MAX: u64 = 9223372036854775807;
pub const QUAD_MIN: i64 = -9223372036854775808;
pub const ARG_MAX: u32 = 1048576;
pub const CHILD_MAX: u32 = 266;
pub const GID_MAX: u32 = 2147483647;
pub const LINK_MAX: u32 = 32767;
pub const MAX_CANON: u32 = 1024;
pub const MAX_INPUT: u32 = 1024;
pub const NAME_MAX: u32 = 255;
pub const NGROUPS_MAX: u32 = 16;
pub const UID_MAX: u32 = 2147483647;
pub const OPEN_MAX: u32 = 10240;
pub const PATH_MAX: u32 = 1024;
pub const PIPE_BUF: u32 = 512;
pub const BC_BASE_MAX: u32 = 99;
pub const BC_DIM_MAX: u32 = 2048;
pub const BC_SCALE_MAX: u32 = 99;
pub const BC_STRING_MAX: u32 = 1000;
pub const CHARCLASS_NAME_MAX: u32 = 14;
pub const COLL_WEIGHTS_MAX: u32 = 2;
pub const EQUIV_CLASS_MAX: u32 = 2;
pub const EXPR_NEST_MAX: u32 = 32;
pub const LINE_MAX: u32 = 2048;
pub const RE_DUP_MAX: u32 = 255;
pub const NZERO: u32 = 20;
pub const _POSIX_ARG_MAX: u32 = 4096;
pub const _POSIX_CHILD_MAX: u32 = 25;
pub const _POSIX_LINK_MAX: u32 = 8;
pub const _POSIX_MAX_CANON: u32 = 255;
pub const _POSIX_MAX_INPUT: u32 = 255;
pub const _POSIX_NAME_MAX: u32 = 14;
pub const _POSIX_NGROUPS_MAX: u32 = 8;
pub const _POSIX_OPEN_MAX: u32 = 20;
pub const _POSIX_PATH_MAX: u32 = 256;
pub const _POSIX_PIPE_BUF: u32 = 512;
pub const _POSIX_SSIZE_MAX: u32 = 32767;
pub const _POSIX_STREAM_MAX: u32 = 8;
pub const _POSIX_TZNAME_MAX: u32 = 6;
pub const _POSIX2_BC_BASE_MAX: u32 = 99;
pub const _POSIX2_BC_DIM_MAX: u32 = 2048;
pub const _POSIX2_BC_SCALE_MAX: u32 = 99;
pub const _POSIX2_BC_STRING_MAX: u32 = 1000;
pub const _POSIX2_EQUIV_CLASS_MAX: u32 = 2;
pub const _POSIX2_EXPR_NEST_MAX: u32 = 32;
pub const _POSIX2_LINE_MAX: u32 = 2048;
pub const _POSIX2_RE_DUP_MAX: u32 = 255;
pub const _POSIX_AIO_LISTIO_MAX: u32 = 2;
pub const _POSIX_AIO_MAX: u32 = 1;
pub const _POSIX_DELAYTIMER_MAX: u32 = 32;
pub const _POSIX_MQ_OPEN_MAX: u32 = 8;
pub const _POSIX_MQ_PRIO_MAX: u32 = 32;
pub const _POSIX_RTSIG_MAX: u32 = 8;
pub const _POSIX_SEM_NSEMS_MAX: u32 = 256;
pub const _POSIX_SEM_VALUE_MAX: u32 = 32767;
pub const _POSIX_SIGQUEUE_MAX: u32 = 32;
pub const _POSIX_TIMER_MAX: u32 = 32;
pub const _POSIX_CLOCKRES_MIN: u32 = 20000000;
pub const _POSIX_THREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const _POSIX_THREAD_KEYS_MAX: u32 = 128;
pub const _POSIX_THREAD_THREADS_MAX: u32 = 64;
pub const PTHREAD_DESTRUCTOR_ITERATIONS: u32 = 4;
pub const PTHREAD_KEYS_MAX: u32 = 512;
pub const PTHREAD_STACK_MIN: u32 = 16384;
pub const _POSIX_HOST_NAME_MAX: u32 = 255;
pub const _POSIX_LOGIN_NAME_MAX: u32 = 9;
pub const _POSIX_SS_REPL_MAX: u32 = 4;
pub const _POSIX_SYMLINK_MAX: u32 = 255;
pub const _POSIX_SYMLOOP_MAX: u32 = 8;
pub const _POSIX_TRACE_EVENT_NAME_MAX: u32 = 30;
pub const _POSIX_TRACE_NAME_MAX: u32 = 8;
pub const _POSIX_TRACE_SYS_MAX: u32 = 8;
pub const _POSIX_TRACE_USER_EVENT_MAX: u32 = 32;
pub const _POSIX_TTY_NAME_MAX: u32 = 9;
pub const _POSIX2_CHARCLASS_NAME_MAX: u32 = 14;
pub const _POSIX2_COLL_WEIGHTS_MAX: u32 = 2;
pub const _POSIX_RE_DUP_MAX: u32 = 255;
pub const OFF_MIN: i64 = -9223372036854775808;
pub const OFF_MAX: u64 = 9223372036854775807;
pub const PASS_MAX: u32 = 128;
pub const NL_ARGMAX: u32 = 9;
pub const NL_LANGMAX: u32 = 14;
pub const NL_MSGMAX: u32 = 32767;
pub const NL_NMAX: u32 = 1;
pub const NL_SETMAX: u32 = 255;
pub const NL_TEXTMAX: u32 = 2048;
pub const _XOPEN_IOV_MAX: u32 = 16;
pub const IOV_MAX: u32 = 1024;
pub const _XOPEN_NAME_MAX: u32 = 255;
pub const _XOPEN_PATH_MAX: u32 = 1024;
pub type int_least8_t = i8;
pub type int_least16_t = i16;
pub type int_least32_t = i32;
pub type int_least64_t = i64;
pub type uint_least8_t = u8;
pub type uint_least16_t = u16;
pub type uint_least32_t = u32;
pub type uint_least64_t = u64;
pub type int_fast8_t = i8;
pub type int_fast16_t = i16;
pub type int_fast32_t = i32;
pub type int_fast64_t = i64;
pub type uint_fast8_t = u8;
pub type uint_fast16_t = u16;
pub type uint_fast32_t = u32;
pub type uint_fast64_t = u64;
pub type __int8_t = ::std::os::raw::c_schar;
pub type __uint8_t = ::std::os::raw::c_uchar;
pub type __int16_t = ::std::os::raw::c_short;
pub type __uint16_t = ::std::os::raw::c_ushort;
pub type __int32_t = ::std::os::raw::c_int;
pub type __uint32_t = ::std::os::raw::c_uint;
pub type __int64_t = ::std::os::raw::c_longlong;
pub type __uint64_t = ::std::os::raw::c_ulonglong;
pub type __darwin_intptr_t = ::std::os::raw::c_long;
pub type __darwin_natural_t = ::std::os::raw::c_uint;
pub type __darwin_ct_rune_t = ::std::os::raw::c_int;
#[repr(C)]
#[derive(Copy, Clone)]
pub union __mbstate_t {
    pub __mbstate8: [::std::os::raw::c_char; 128usize],
    pub _mbstateL: ::std::os::raw::c_longlong,
}
#[test]
fn bindgen_test_layout___mbstate_t() {
    const UNINIT: ::std::mem::MaybeUninit<__mbstate_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__mbstate_t>(),
        128usize,
        concat!("Size of: ", stringify!(__mbstate_t))
    );
    assert_eq!(
        ::std::mem::align_of::<__mbstate_t>(),
        8usize,
        concat!("Alignment of ", stringify!(__mbstate_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__mbstate8) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(__mbstate8)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr)._mbstateL) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__mbstate_t),
            "::",
            stringify!(_mbstateL)
        )
    );
}
pub type __darwin_mbstate_t = __mbstate_t;
pub type __darwin_ptrdiff_t = ::std::os::raw::c_long;
pub type __darwin_size_t = ::std::os::raw::c_ulong;
pub type __darwin_va_list = __builtin_va_list;
pub type __darwin_wchar_t = ::std::os::raw::c_int;
pub type __darwin_rune_t = __darwin_wchar_t;
pub type __darwin_wint_t = ::std::os::raw::c_int;
pub type __darwin_clock_t = ::std::os::raw::c_ulong;
pub type __darwin_socklen_t = __uint32_t;
pub type __darwin_ssize_t = ::std::os::raw::c_long;
pub type __darwin_time_t = ::std::os::raw::c_long;
pub type __darwin_blkcnt_t = __int64_t;
pub type __darwin_blksize_t = __int32_t;
pub type __darwin_dev_t = __int32_t;
pub type __darwin_fsblkcnt_t = ::std::os::raw::c_uint;
pub type __darwin_fsfilcnt_t = ::std::os::raw::c_uint;
pub type __darwin_gid_t = __uint32_t;
pub type __darwin_id_t = __uint32_t;
pub type __darwin_ino64_t = __uint64_t;
pub type __darwin_ino_t = __darwin_ino64_t;
pub type __darwin_mach_port_name_t = __darwin_natural_t;
pub type __darwin_mach_port_t = __darwin_mach_port_name_t;
pub type __darwin_mode_t = __uint16_t;
pub type __darwin_off_t = __int64_t;
pub type __darwin_pid_t = __int32_t;
pub type __darwin_sigset_t = __uint32_t;
pub type __darwin_suseconds_t = __int32_t;
pub type __darwin_uid_t = __uint32_t;
pub type __darwin_useconds_t = __uint32_t;
pub type __darwin_uuid_t = [::std::os::raw::c_uchar; 16usize];
pub type __darwin_uuid_string_t = [::std::os::raw::c_char; 37usize];
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct __darwin_pthread_handler_rec {
    pub __routine: ::std::option::Option<unsafe extern "C" fn(arg1: *mut ::std::os::raw::c_void)>,
    pub __arg: *mut ::std::os::raw::c_void,
    pub __next: *mut __darwin_pthread_handler_rec,
}
#[test]
fn bindgen_test_layout___darwin_pthread_handler_rec() {
    const UNINIT: ::std::mem::MaybeUninit<__darwin_pthread_handler_rec> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<__darwin_pthread_handler_rec>(),
        24usize,
        concat!("Size of: ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        ::std::mem::align_of::<__darwin_pthread_handler_rec>(),
        8usize,
        concat!("Alignment of ", stringify!(__darwin_pthread_handler_rec))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__routine) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__routine)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__arg) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__arg)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__next) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(__darwin_pthread_handler_rec),
            "::",
            stringify!(__next)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_attr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_attr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_attr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_attr_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_attr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_attr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_attr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_cond_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 40usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_cond_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_cond_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_cond_t>(),
        48usize,
        concat!("Size of: ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_cond_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_cond_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_cond_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_condattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_condattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_condattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_condattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_condattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_condattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_condattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutex_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 56usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutex_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutex_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutex_t>(),
        64usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutex_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutex_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutex_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_mutexattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_mutexattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_mutexattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_mutexattr_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_mutexattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_mutexattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_mutexattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_once_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 8usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_once_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_once_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_once_t>(),
        16usize,
        concat!("Size of: ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_once_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_once_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_once_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlock_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 192usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlock_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlock_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlock_t>(),
        200usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlock_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlock_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlock_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_rwlockattr_t {
    pub __sig: ::std::os::raw::c_long,
    pub __opaque: [::std::os::raw::c_char; 16usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_rwlockattr_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_rwlockattr_t> =
        ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_rwlockattr_t>(),
        24usize,
        concat!("Size of: ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_rwlockattr_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_rwlockattr_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_rwlockattr_t),
            "::",
            stringify!(__opaque)
        )
    );
}
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct _opaque_pthread_t {
    pub __sig: ::std::os::raw::c_long,
    pub __cleanup_stack: *mut __darwin_pthread_handler_rec,
    pub __opaque: [::std::os::raw::c_char; 8176usize],
}
#[test]
fn bindgen_test_layout__opaque_pthread_t() {
    const UNINIT: ::std::mem::MaybeUninit<_opaque_pthread_t> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<_opaque_pthread_t>(),
        8192usize,
        concat!("Size of: ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        ::std::mem::align_of::<_opaque_pthread_t>(),
        8usize,
        concat!("Alignment of ", stringify!(_opaque_pthread_t))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__sig) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__sig)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__cleanup_stack) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__cleanup_stack)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).__opaque) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(_opaque_pthread_t),
            "::",
            stringify!(__opaque)
        )
    );
}
pub type __darwin_pthread_attr_t = _opaque_pthread_attr_t;
pub type __darwin_pthread_cond_t = _opaque_pthread_cond_t;
pub type __darwin_pthread_condattr_t = _opaque_pthread_condattr_t;
pub type __darwin_pthread_key_t = ::std::os::raw::c_ulong;
pub type __darwin_pthread_mutex_t = _opaque_pthread_mutex_t;
pub type __darwin_pthread_mutexattr_t = _opaque_pthread_mutexattr_t;
pub type __darwin_pthread_once_t = _opaque_pthread_once_t;
pub type __darwin_pthread_rwlock_t = _opaque_pthread_rwlock_t;
pub type __darwin_pthread_rwlockattr_t = _opaque_pthread_rwlockattr_t;
pub type __darwin_pthread_t = *mut _opaque_pthread_t;
pub type u_int8_t = ::std::os::raw::c_uchar;
pub type u_int16_t = ::std::os::raw::c_ushort;
pub type u_int32_t = ::std::os::raw::c_uint;
pub type u_int64_t = ::std::os::raw::c_ulonglong;
pub type register_t = i64;
pub type user_addr_t = u_int64_t;
pub type user_size_t = u_int64_t;
pub type user_ssize_t = i64;
pub type user_long_t = i64;
pub type user_ulong_t = u_int64_t;
pub type user_time_t = i64;
pub type user_off_t = i64;
pub type syscall_arg_t = u_int64_t;
pub type intmax_t = ::std::os::raw::c_long;
pub type uintmax_t = ::std::os::raw::c_ulong;
pub type rsize_t = ::std::os::raw::c_ulong;
pub type wchar_t = ::std::os::raw::c_int;
pub type max_align_t = f64;
extern "C" {
    pub static mut FLAG_clear_internal_memory: ::std::os::raw::c_int;
}
pub const Argon2_ErrorCodes_ARGON2_OK: Argon2_ErrorCodes = 0;
pub const Argon2_ErrorCodes_ARGON2_OUTPUT_PTR_NULL: Argon2_ErrorCodes = -1;
pub const Argon2_ErrorCodes_ARGON2_OUTPUT_TOO_SHORT: Argon2_ErrorCodes = -2;
pub const Argon2_ErrorCodes_ARGON2_OUTPUT_TOO_LONG: Argon2_ErrorCodes = -3;
pub const Argon2_ErrorCodes_ARGON2_PWD_TOO_SHORT: Argon2_ErrorCodes = -4;
pub const Argon2_ErrorCodes_ARGON2_PWD_TOO_LONG: Argon2_ErrorCodes = -5;
pub const Argon2_ErrorCodes_ARGON2_SALT_TOO_SHORT: Argon2_ErrorCodes = -6;
pub const Argon2_ErrorCodes_ARGON2_SALT_TOO_LONG: Argon2_ErrorCodes = -7;
pub const Argon2_ErrorCodes_ARGON2_AD_TOO_SHORT: Argon2_ErrorCodes = -8;
pub const Argon2_ErrorCodes_ARGON2_AD_TOO_LONG: Argon2_ErrorCodes = -9;
pub const Argon2_ErrorCodes_ARGON2_SECRET_TOO_SHORT: Argon2_ErrorCodes = -10;
pub const Argon2_ErrorCodes_ARGON2_SECRET_TOO_LONG: Argon2_ErrorCodes = -11;
pub const Argon2_ErrorCodes_ARGON2_TIME_TOO_SMALL: Argon2_ErrorCodes = -12;
pub const Argon2_ErrorCodes_ARGON2_TIME_TOO_LARGE: Argon2_ErrorCodes = -13;
pub const Argon2_ErrorCodes_ARGON2_MEMORY_TOO_LITTLE: Argon2_ErrorCodes = -14;
pub const Argon2_ErrorCodes_ARGON2_MEMORY_TOO_MUCH: Argon2_ErrorCodes = -15;
pub const Argon2_ErrorCodes_ARGON2_LANES_TOO_FEW: Argon2_ErrorCodes = -16;
pub const Argon2_ErrorCodes_ARGON2_LANES_TOO_MANY: Argon2_ErrorCodes = -17;
pub const Argon2_ErrorCodes_ARGON2_PWD_PTR_MISMATCH: Argon2_ErrorCodes = -18;
pub const Argon2_ErrorCodes_ARGON2_SALT_PTR_MISMATCH: Argon2_ErrorCodes = -19;
pub const Argon2_ErrorCodes_ARGON2_SECRET_PTR_MISMATCH: Argon2_ErrorCodes = -20;
pub const Argon2_ErrorCodes_ARGON2_AD_PTR_MISMATCH: Argon2_ErrorCodes = -21;
pub const Argon2_ErrorCodes_ARGON2_MEMORY_ALLOCATION_ERROR: Argon2_ErrorCodes = -22;
pub const Argon2_ErrorCodes_ARGON2_FREE_MEMORY_CBK_NULL: Argon2_ErrorCodes = -23;
pub const Argon2_ErrorCodes_ARGON2_ALLOCATE_MEMORY_CBK_NULL: Argon2_ErrorCodes = -24;
pub const Argon2_ErrorCodes_ARGON2_INCORRECT_PARAMETER: Argon2_ErrorCodes = -25;
pub const Argon2_ErrorCodes_ARGON2_INCORRECT_TYPE: Argon2_ErrorCodes = -26;
pub const Argon2_ErrorCodes_ARGON2_OUT_PTR_MISMATCH: Argon2_ErrorCodes = -27;
pub const Argon2_ErrorCodes_ARGON2_THREADS_TOO_FEW: Argon2_ErrorCodes = -28;
pub const Argon2_ErrorCodes_ARGON2_THREADS_TOO_MANY: Argon2_ErrorCodes = -29;
pub const Argon2_ErrorCodes_ARGON2_MISSING_ARGS: Argon2_ErrorCodes = -30;
pub const Argon2_ErrorCodes_ARGON2_ENCODING_FAIL: Argon2_ErrorCodes = -31;
pub const Argon2_ErrorCodes_ARGON2_DECODING_FAIL: Argon2_ErrorCodes = -32;
pub const Argon2_ErrorCodes_ARGON2_THREAD_FAIL: Argon2_ErrorCodes = -33;
pub const Argon2_ErrorCodes_ARGON2_DECODING_LENGTH_FAIL: Argon2_ErrorCodes = -34;
pub const Argon2_ErrorCodes_ARGON2_VERIFY_MISMATCH: Argon2_ErrorCodes = -35;
pub type Argon2_ErrorCodes = ::std::os::raw::c_int;
pub use self::Argon2_ErrorCodes as argon2_error_codes;
pub type allocate_fptr = ::std::option::Option<
    unsafe extern "C" fn(memory: *mut *mut u8, bytes_to_allocate: usize) -> ::std::os::raw::c_int,
>;
pub type deallocate_fptr =
    ::std::option::Option<unsafe extern "C" fn(memory: *mut u8, bytes_to_allocate: usize)>;
#[repr(C)]
#[derive(Debug, Copy, Clone)]
pub struct Argon2_Context {
    pub out: *mut u8,
    pub outlen: u32,
    pub pwd: *mut u8,
    pub pwdlen: u32,
    pub salt: *mut u8,
    pub saltlen: u32,
    pub secret: *mut u8,
    pub secretlen: u32,
    pub ad: *mut u8,
    pub adlen: u32,
    pub t_cost: u32,
    pub m_cost: u32,
    pub lanes: u32,
    pub threads: u32,
    pub version: u32,
    pub allocate_cbk: allocate_fptr,
    pub free_cbk: deallocate_fptr,
    pub flags: u32,
}
#[test]
fn bindgen_test_layout_Argon2_Context() {
    const UNINIT: ::std::mem::MaybeUninit<Argon2_Context> = ::std::mem::MaybeUninit::uninit();
    let ptr = UNINIT.as_ptr();
    assert_eq!(
        ::std::mem::size_of::<Argon2_Context>(),
        120usize,
        concat!("Size of: ", stringify!(Argon2_Context))
    );
    assert_eq!(
        ::std::mem::align_of::<Argon2_Context>(),
        8usize,
        concat!("Alignment of ", stringify!(Argon2_Context))
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).out) as usize - ptr as usize },
        0usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(out)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).outlen) as usize - ptr as usize },
        8usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(outlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pwd) as usize - ptr as usize },
        16usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(pwd)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).pwdlen) as usize - ptr as usize },
        24usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(pwdlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).salt) as usize - ptr as usize },
        32usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(salt)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).saltlen) as usize - ptr as usize },
        40usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(saltlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secret) as usize - ptr as usize },
        48usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(secret)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).secretlen) as usize - ptr as usize },
        56usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(secretlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).ad) as usize - ptr as usize },
        64usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(ad)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).adlen) as usize - ptr as usize },
        72usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(adlen)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).t_cost) as usize - ptr as usize },
        76usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(t_cost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).m_cost) as usize - ptr as usize },
        80usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(m_cost)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).lanes) as usize - ptr as usize },
        84usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(lanes)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).threads) as usize - ptr as usize },
        88usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(threads)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).version) as usize - ptr as usize },
        92usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(version)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).allocate_cbk) as usize - ptr as usize },
        96usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(allocate_cbk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).free_cbk) as usize - ptr as usize },
        104usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(free_cbk)
        )
    );
    assert_eq!(
        unsafe { ::std::ptr::addr_of!((*ptr).flags) as usize - ptr as usize },
        112usize,
        concat!(
            "Offset of field: ",
            stringify!(Argon2_Context),
            "::",
            stringify!(flags)
        )
    );
}
pub type argon2_context = Argon2_Context;
pub const Argon2_type_Argon2_d: Argon2_type = 0;
pub const Argon2_type_Argon2_i: Argon2_type = 1;
pub const Argon2_type_Argon2_id: Argon2_type = 2;
pub type Argon2_type = ::std::os::raw::c_uint;
pub use self::Argon2_type as argon2_type;
pub const Argon2_version_ARGON2_VERSION_10: Argon2_version = 16;
pub const Argon2_version_ARGON2_VERSION_13: Argon2_version = 19;
pub const Argon2_version_ARGON2_VERSION_NUMBER: Argon2_version = 19;
pub type Argon2_version = ::std::os::raw::c_uint;
pub use self::Argon2_version as argon2_version;
extern "C" {
    pub fn argon2_type2string(
        type_: argon2_type,
        uppercase: ::std::os::raw::c_int,
    ) -> *const ::std::os::raw::c_char;
}
extern "C" {
    pub fn argon2_ctx(context: *mut argon2_context, type_: argon2_type) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hashes a password with Argon2i, producing an encoded hash\n @param t_cost Number of iterations\n @param m_cost Sets memory usage to m_cost kibibytes\n @param parallelism Number of threads and compute lanes\n @param pwd Pointer to password\n @param pwdlen Password size in bytes\n @param salt Pointer to salt\n @param saltlen Salt size in bytes\n @param hashlen Desired length of the hash in bytes\n @param encoded Buffer where to write the encoded hash\n @param encodedlen Size of the buffer (thus max size of the encoded hash)\n @pre   Different parallelism levels will give different results\n @pre   Returns ARGON2_OK if successful"]
    pub fn argon2i_hash_encoded(
        t_cost: u32,
        m_cost: u32,
        parallelism: u32,
        pwd: *const ::std::os::raw::c_void,
        pwdlen: usize,
        salt: *const ::std::os::raw::c_void,
        saltlen: usize,
        hashlen: usize,
        encoded: *mut ::std::os::raw::c_char,
        encodedlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Hashes a password with Argon2i, producing a raw hash at @hash\n @param t_cost Number of iterations\n @param m_cost Sets memory usage to m_cost kibibytes\n @param parallelism Number of threads and compute lanes\n @param pwd Pointer to password\n @param pwdlen Password size in bytes\n @param salt Pointer to salt\n @param saltlen Salt size in bytes\n @param hash Buffer where to write the raw hash - updated by the function\n @param hashlen Desired length of the hash in bytes\n @pre   Different parallelism levels will give different results\n @pre   Returns ARGON2_OK if successful"]
    pub fn argon2i_hash_raw(
        t_cost: u32,
        m_cost: u32,
        parallelism: u32,
        pwd: *const ::std::os::raw::c_void,
        pwdlen: usize,
        salt: *const ::std::os::raw::c_void,
        saltlen: usize,
        hash: *mut ::std::os::raw::c_void,
        hashlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argon2d_hash_encoded(
        t_cost: u32,
        m_cost: u32,
        parallelism: u32,
        pwd: *const ::std::os::raw::c_void,
        pwdlen: usize,
        salt: *const ::std::os::raw::c_void,
        saltlen: usize,
        hashlen: usize,
        encoded: *mut ::std::os::raw::c_char,
        encodedlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argon2d_hash_raw(
        t_cost: u32,
        m_cost: u32,
        parallelism: u32,
        pwd: *const ::std::os::raw::c_void,
        pwdlen: usize,
        salt: *const ::std::os::raw::c_void,
        saltlen: usize,
        hash: *mut ::std::os::raw::c_void,
        hashlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argon2id_hash_encoded(
        t_cost: u32,
        m_cost: u32,
        parallelism: u32,
        pwd: *const ::std::os::raw::c_void,
        pwdlen: usize,
        salt: *const ::std::os::raw::c_void,
        saltlen: usize,
        hashlen: usize,
        encoded: *mut ::std::os::raw::c_char,
        encodedlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argon2id_hash_raw(
        t_cost: u32,
        m_cost: u32,
        parallelism: u32,
        pwd: *const ::std::os::raw::c_void,
        pwdlen: usize,
        salt: *const ::std::os::raw::c_void,
        saltlen: usize,
        hash: *mut ::std::os::raw::c_void,
        hashlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argon2_hash(
        t_cost: u32,
        m_cost: u32,
        parallelism: u32,
        pwd: *const ::std::os::raw::c_void,
        pwdlen: usize,
        salt: *const ::std::os::raw::c_void,
        saltlen: usize,
        hash: *mut ::std::os::raw::c_void,
        hashlen: usize,
        encoded: *mut ::std::os::raw::c_char,
        encodedlen: usize,
        type_: argon2_type,
        version: u32,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verifies a password against an encoded string\n Encoded string is restricted as in validate_inputs()\n @param encoded String encoding parameters, salt, hash\n @param pwd Pointer to password\n @pre   Returns ARGON2_OK if successful"]
    pub fn argon2i_verify(
        encoded: *const ::std::os::raw::c_char,
        pwd: *const ::std::os::raw::c_void,
        pwdlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argon2d_verify(
        encoded: *const ::std::os::raw::c_char,
        pwd: *const ::std::os::raw::c_void,
        pwdlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argon2id_verify(
        encoded: *const ::std::os::raw::c_char,
        pwd: *const ::std::os::raw::c_void,
        pwdlen: usize,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argon2_verify(
        encoded: *const ::std::os::raw::c_char,
        pwd: *const ::std::os::raw::c_void,
        pwdlen: usize,
        type_: argon2_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Argon2d: Version of Argon2 that picks memory blocks depending\n on the password and salt. Only for side-channel-free\n environment!!\n\n @param  context  Pointer to current Argon2 context\n @return  Zero if successful, a non zero error code otherwise"]
    pub fn argon2d_ctx(context: *mut argon2_context) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Argon2i: Version of Argon2 that picks memory blocks\n independent on the password and salt. Good for side-channels,\n but worse w.r.t. tradeoff attacks if only one pass is used.\n\n @param  context  Pointer to current Argon2 context\n @return  Zero if successful, a non zero error code otherwise"]
    pub fn argon2i_ctx(context: *mut argon2_context) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Argon2id: Version of Argon2 where the first half-pass over memory is\n password-independent, the rest are password-dependent (on the password and\n salt). OK against side channels (they reduce to 1/2-pass Argon2i), and\n better with w.r.t. tradeoff attacks (similar to Argon2d).\n\n @param  context  Pointer to current Argon2 context\n @return  Zero if successful, a non zero error code otherwise"]
    pub fn argon2id_ctx(context: *mut argon2_context) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verify if a given password is correct for Argon2d hashing\n @param  context  Pointer to current Argon2 context\n @param  hash  The password hash to verify. The length of the hash is\n specified by the context outlen member\n @return  Zero if successful, a non zero error code otherwise"]
    pub fn argon2d_verify_ctx(
        context: *mut argon2_context,
        hash: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verify if a given password is correct for Argon2i hashing\n @param  context  Pointer to current Argon2 context\n @param  hash  The password hash to verify. The length of the hash is\n specified by the context outlen member\n @return  Zero if successful, a non zero error code otherwise"]
    pub fn argon2i_verify_ctx(
        context: *mut argon2_context,
        hash: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Verify if a given password is correct for Argon2id hashing\n @param  context  Pointer to current Argon2 context\n @param  hash  The password hash to verify. The length of the hash is\n specified by the context outlen member\n @return  Zero if successful, a non zero error code otherwise"]
    pub fn argon2id_verify_ctx(
        context: *mut argon2_context,
        hash: *const ::std::os::raw::c_char,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    pub fn argon2_verify_ctx(
        context: *mut argon2_context,
        hash: *const ::std::os::raw::c_char,
        type_: argon2_type,
    ) -> ::std::os::raw::c_int;
}
extern "C" {
    #[doc = " Get the associated error message for given error code\n @return  The error message associated with the given error code"]
    pub fn argon2_error_message(error_code: ::std::os::raw::c_int)
        -> *const ::std::os::raw::c_char;
}
extern "C" {
    #[doc = " Returns the encoded hash length for the given input parameters\n @param t_cost  Number of iterations\n @param m_cost  Memory usage in kibibytes\n @param parallelism  Number of threads; used to compute lanes\n @param saltlen  Salt size in bytes\n @param hashlen  Hash size in bytes\n @param type The argon2_type that we want the encoded length for\n @return  The encoded hash length in bytes"]
    pub fn argon2_encodedlen(
        t_cost: u32,
        m_cost: u32,
        parallelism: u32,
        saltlen: u32,
        hashlen: u32,
        type_: argon2_type,
    ) -> usize;
}
pub type __builtin_va_list = *mut ::std::os::raw::c_char;
